<!--
Copyright 2017 Next Century Corporation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../d3-import/d3.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../loading-spinner/loading-spinner.html">
<link rel="import" href="../lodash-import/lodash.html">
<link rel="import" href="../moment-element/moment-with-locales-import.html">

<!--
A Polymer element that creates a bar chart using d3 with the ability to
zoom in on specific areas of the data.

### Example
```html
<zoomable-bar-chart timeline
  load
  bar-property="bar"
  stack-property="stack"
  data="[[data]]"
  default-label="Unknown Location"
  height="300"
  loading="[[chartLoading]]"
  selected="[[selected]]">
</zoomable-bar-chart>
```

@demo demo/index.html
-->

<dom-module id="zoomable-bar-chart">
  <template>
    <style include="iron-flex"></style>

    <style>
      :host {
        @apply --layout-horizontal;
        @apply --layout-flex-auto;
      }

      #barChart {
        display: none;
        height: 0;
        width: 0;
      }

      #barChart[show] {
        display: block;
      }

      .axis {
        font-size: 12px;
        fill: #212121; /* paper-grey-900 */
      }

      .axis line, .axis path {
        fill: none;
        stroke: #212121; /* paper-grey-900 */
        shape-rendering: crispEdges;
      }

      .brush .extent {
        fill-opacity: 0.25;
        shape-rendering: crispEdges;
      }
    </style>

    <loading-spinner show="[[loading]]" type="Bar Chart"></loading-spinner>

    <svg id="barChart" show$="[[!loading]]"></svg>
  </template>

  <script>
    (function() {
      'use strict';

      Polymer({
        is: 'zoomable-bar-chart',

        properties: {
          /**
           * (Optional)
           *
           * The property of the objects in the data containing the unique bar string or date-string used in the x-axis.
           *
           * @type {String}
           * @default 'bar'
           */
          barProperty: {
            type: String,
            value: 'bar'
          },

          /**
           * (Optional)
           *
           * The property of the objects in the data containing the list of stacks on each bar.
           *
           * @type {String}
           * @default 'stack'
           */
          stackProperty: {
            type: String,
            value: 'stack'
          },

          /**
           * (Optional)
           *
           * The property of the objects in the list of stacks containing the count of that stack.
           *
           * @type {String}
           * @default 'count'
           */
          countProperty: {
            type: String,
            value: 'count'
          },

          /**
           * (Optional)
           *
           * The property of the objects in the list of stacks containing the label of that stack.
           *
           * @type {String}
           * @default 'label'
           */
          labelProperty: {
            type: String,
            value: 'label'
          },

          /**
           * (Optional)
           *
           * The color given to bars that do not have labels.
           *
           * @type {String}
           * @default '#757575'
           */
          defaultColor: {
            type: String,
            value: '#757575' /* paper-grey-600 */
          },

          /**
           * (Optional)
           *
           * The label given to bars that do not have labels.
           *
           * @type {String}
           * @default 'Other'
           */
          defaultLabel: {
            type: String,
            value: 'Other'
          },

          /**
           * (Optional)
           *
           * The height for this bar chart (in pixels).
           *
           * @type {Number}
           * @default 400
           */
          height: {
            type: Number,
            value: 400
          },

          /**
           * (Optional)
           *
           * Whether to hide the bar chart axes and grid.
           *
           * @type {Boolean}
           * @default false
           */
          hideAxes: {
            type: Boolean,
            value: false
          },

          /**
           * (Optional)
           *
           * Whether to hide the bar chart grid.
           *
           * @type {Boolean}
           * @default false
           */
          hideGrid: {
            type: Boolean,
            value: false
          },

          /**
           * (Optional)
           *
           * Whether to hide the bar chart overview.
           *
           * @type {Boolean}
           * @default false
           */
          hideOverview: {
            type: Boolean,
            value: false
          },

          /**
           * (Optional)
           *
           * The source of the data to use in the info text for this bar chart.
           *
           * @type {String}
           * @default 'Data'
           */
          source: {
            type: String,
            value: 'Data'
          },

          /**
           * (Optional)
           *
           * Whether the bar chart is a timeline (its bars and x-axis are dates).
           *
           * @type {Boolean}
           * @default false
           */
          timeline: {
            type: Boolean,
            value: false
          },

          /**
           * (Required)
           *
           * The time interval for the x-axis. Should be one of the following options:
           * - 'hour'
           * - 'day'
           * - 'week'
           * - 'month'
           * - 'year'
           *
           * @type {String}
           * @default 'year'
           */
          interval: {
            type: String,
            value: 'year'
          },

          /**
           * (Required)
           *
           * The data to display in the bar chart.
           *
           * @type {Array}
           * @default []
           */
          data: {
            type: Array,
            value: function() {
              return [];
            },
            notify: true
          },

          /**
           * (Output)
           *
           * Whether the data is loading.
           *
           * @type {Boolean}
           * @default false
           */
          loading: {
            type: Boolean,
            value: false,
            notify: true
          },

          /**
           * (Optional)
           *
           * Domain values currently selected in the chart. If this chart is a timeline,
           * the start date and end date will be saved in this array as strings.
           * Otherwise, all terms selected will be saved in the array.
           * Either a list or an object containing a list at its `selectedProperty` property.
           *
           * @type {Array|Object}
           */
          selected: {
            notify: true,
            type: Object
          },

          /**
           * (Optional)
           *
           * The property in the `selected` object containing the list of selected dates or string IDs.  If undefined, assumes that `selected` itself is a list.
           *
           * @type {String}
           */
          selectedProperty: {
            type: String
          },

          /**
           * (Optional)
           *
           * Whether or not to display instructions about filtering in the area where a user can zoom
           * in on the data.
           *
           * @type {Boolean}
           * @default false
           */
          displayFilterText: {
            type: Boolean,
            value: false
          },

          /**
           * (Optional)
           *
           * Whether to load the bar chart data.
           *
           * @type {Boolean}
           * @default false
           */
          load: {
            type: Boolean,
            value: false
          },

          /**
           * The data that is displayed in the bar chart.  Computed from the data.
           *
           * @default []
           * @private
           */
          _bars: {
            type: Array,
            value: function() {
              return [];
            }
          },

          /**
           * The set of parts that are displayed in the bar chart.  Computed from the data.
           *
           * @default []
           * @private
           */
          _legend: {
            type: Array,
            value: function() {
              return [];
            }
          },

          /**
           * The unique ID of this bar chart.
           *
           * @type {Number}
           * @private
           */
          _uuid: {
            type: Number,
            value: function() {
              return Math.random();
            }
          }
        },

        observers: [
          '_checkData(data, interval, load, timeline)'
        ],

        /**
         * If data exists, create bar chart.
         *
         * @param {Array} data
         * @param {String} interval
         * @param {Boolean} load
         * @param {Boolean} timeline
         * @private
         */
        _checkData: function(data, interval, load, timeline) {
          if(!data || !data.length || !interval || !load || typeof timeline === 'undefined') {
            var children = this.$.barChart.children;
            for(var i = 0; i < children.length; i++) {
              this.$.barChart.removeChild(children[i]);
            }
            this.$.barChart.removeAttribute('style');
            return;
          }

          var bars = this._createBars(data, interval, timeline);
          this._createElements(bars, interval, timeline);

          var self = this;
          Polymer.RenderStatus.afterNextRender(this, function() {
            self.resize();
          });
        },

        /**
         * If using chart as a timeline, add empty bars for dates on timeline
         * that don't have data.
         *
         * @param {Array} oldBars
         * @param {String} interval
         * @return {Array} newBars
         * @private
         */
        _addMissingTimelineBars: function(oldBars, interval) {
          var self = this;
          var newBars = [];

          var times = oldBars.map(function(bar) {
            return bar.barValue.getTime();
          });

          // Add 0-count bars for all dates on the timeline without data.
          d3.time.scale().domain(d3.extent(oldBars, function(bar) {
            return bar.barValue;
          })).ticks(self._getD3Interval(interval), 1).map(function(tick) {
            return {
              object: tick,
              number: tick.getTime()
            };
          }).forEach(function(tick) {
            var barIndex = times.indexOf(tick.number);
            if(barIndex >= 0) {
              newBars.push(oldBars[barIndex]);
            } else {
              newBars.push({
                stacks: [],
                barValue: tick.object,
                barLabel: self._getDateText(tick.object, interval),
                barCount: 0
              });
            }
          });

          return newBars;
        },

        /**
         * Creates bars for the chart and if applicable, a legend.
         *
         * @param {Array} data
         * @param {String} interval
         * @param {Boolean} timeline
         * @private
         */
        _createBars: function(data, interval, timeline) {
          var self = this;
          var bars = [];
          var legend = {};

          if(data) {
            data.forEach(function(bar) {
              var barCount = 0;
              var stacks = [];
              var barValue = timeline ? new Date(bar[self.barProperty]) : bar[self.barProperty];
              var barLabel = timeline ? self._getDateText(barValue, interval) : barValue;
              if(bar[self.stackProperty]) {
                bar[self.stackProperty].forEach(function(stack) {
                  if(stack[self.countProperty]) {
                    var stackLabel = stack[self.labelProperty] || self.defaultLabel;
                    stacks.push({
                      barValue: barValue,
                      barLabel: barLabel,
                      stackLabel: stackLabel,
                      stackStart: barCount,
                      stackEnd: barCount + stack[self.countProperty]
                    });
                    barCount += stack[self.countProperty];
                    legend[stackLabel] = true;
                  }
                });
                stacks.forEach(function(bar) {
                  bar.barCount = barCount;
                });
              } else if(bar[self.countProperty]) {
                barCount = bar[self.countProperty];
                var stackLabel = bar[self.labelProperty] || self.defaultLabel;
                stacks.push({
                  barValue: barValue,
                  barLabel: barLabel,
                  stackLabel: stackLabel,
                  stackStart: 0,
                  stackEnd: barCount
                });
                legend[stackLabel] = true;
              }
              bars.push({
                stacks: stacks,
                barValue: barValue,
                barLabel: barLabel,
                barCount: barCount
              });
            });

            if(timeline) {
              bars = this._addMissingTimelineBars(bars, interval);
            }
          }

          this._bars = bars;
          this._legend = Object.keys(legend).sort();
          return bars;
        },

        /**
         * Create base elements for the bar chart.
         *
         * @param {Array} bars
         * @param {String} interval
         * @param {Boolean} timeline
         * @private
         */
        _createElements: function(bars, interval, timeline) {
          var self = this;

          // Use the width of the bar chart container.
          this.width = (this ? parseInt(this.offsetWidth, 10) : 560) || 560;

          var marginLeft = 50;
          var marginRight = 10;
          var marginTopInfo = 15;
          var marginTopMain = 25;
          var marginBottomMain = this.hideOverview ? 20 : 110;
          var marginTopInstructions = this.height - 70;
          var marginTopOverview = this.height - 60;
          var marginBottomOverview = 20;

          var chartWidth = this.width - marginLeft - marginRight;
          var chartHeight = this.height - marginTopMain - marginBottomMain;
          var overviewHeight = this.height - marginTopOverview - marginBottomOverview;

          var getComputedStyleValueFunction = function(value) {
            if(window.ShadyCSS) {
              return ShadyCSS.getComputedStyleValue(self, value);
            }
            return getComputedStyle(self).getPropertyValue(value);
          };

          var defaultColor = this.defaultColor;
          var color = d3.scale.ordinal().range([
              '#1e88e5', /* paper-blue-600 */
              '#fb8c00', /* paper-orange-600 */
              '#43a047', /* paper-green-600 */
              '#e53935', /* paper-red-600 */
              '#8e24aa', /* paper-purple-600 */
              '#fdd835', /* paper-yellow-600 */
              '#3949ab', /* paper-indigo-600 */
              '#00acc1', /* paper-cyan-600 */
              '#f4511e', /* paper-deep-orange-600 */
              '#c0ca33', /* paper-lime-600 */
              '#d81b60', /* paper-pink-600 */
              '#5e35b1', /* paper-deep-purple-600 */
              '#ffb300', /* paper-amber-600 */
              '#00897b', /* paper-teal-600 */
              '#7cb342', /* paper-light-green-600 */
              '#039be5'  /* paper-light-blue-600 */
          ]);

          var x = d3.scale.ordinal();
          var y = d3.scale.linear().range([chartHeight, 0]);
          var xOverview = d3.scale.ordinal();
          var yOverview = d3.scale.linear().range([overviewHeight, 0]);
          var xAxis, yAxis, xAxisOverview;

          if(!this.hideAxes) {
            xAxis = d3.svg.axis().scale(x).orient('bottom');
            yAxis = d3.svg.axis().scale(y).orient('left').tickFormat(this._formatTickY);
            xAxisOverview = d3.svg.axis().scale(xOverview).orient('bottom');
          }

          var svg = d3.select(document.createElement('div')).append('svg');

          var info = svg.append('text')
            .attr('class', 'info')
            .attr('transform', 'translate(' + marginLeft + ',' + marginTopInfo + ')')
            .style('fill', '#212121')
            .style('font-size', '14px')
            .style('font-weight', '500')
            .text('');

          var main = svg.append('g')
            .attr('class', 'main')
            .attr('transform', 'translate(' + marginLeft + ',' + marginTopMain + ')');

          var overview;

          if(!this.hideOverview) {
            svg.append('text')
              .attr('class', 'instructions')
              .attr('transform', 'translate(' + marginLeft + ',' + marginTopInstructions + ')')
              .style('fill', '#212121')
              .style('font-size', '14px')
              .style('font-weight', '500')
              .text(self._getSelectionInstructions());

            overview = svg.append('g')
              .attr('class', 'overview')
              .attr('transform', 'translate(' + marginLeft + ',' + marginTopOverview + ')');
          }

          this._setXAxis(timeline, interval, bars, chartWidth, x, xAxis, xOverview, xAxisOverview, this.hideAxes);

          var xAxisMax = _.max(_.map(bars, function(item) {
            return x(item.barValue) + x.rangeBand();
          }));
          var yAxisMax = d3.max(bars, function(d) { return d.barCount; });
          var ticks = this._getNumberedAxisTickValues(0, yAxisMax, chartHeight);
          yAxisMax = ticks[ticks.length - 1];
          y.domain([0, yAxisMax]);

          if(!this.hideAxes) {
            yAxis.tickValues(ticks);
          }

          yOverview.domain(y.domain());

          var createExtentText = function() {
            var xDomain = x.domain();
            var from = timeline ? self._getDateText(new Date(xDomain[0]), interval) : xDomain[0];
            var to = timeline ? self._getDateText(new Date(xDomain[xDomain.length - 1]), interval) : xDomain[xDomain.length - 1];
            if(from === to) {
              return self.source + ' on ' + from;
            }
            return self.source + ' from ' + from + ' to ' + to;
          };

          info.text(createExtentText());

          color.domain(this._legend.filter(function(key) {
            return key !== self.defaultLabel;
          }));

          if(!this.hideAxes) {
            main.append('g')
              .attr('class', 'x axis')
              .attr('transform', 'translate(0,' + chartHeight + ')')
              .call(xAxis);
            main.append('g')
              .attr('class', 'y axis')
              .call(yAxis);

            if(!this.hideOverview) {
              overview.append('g')
                .attr('class', 'x axis')
                .attr('transform', 'translate(0,' + overviewHeight + ')')
                .call(xAxisOverview);
            }
          }

          var grid, createGridLines;
          if(!this.hideAxes && !this.hideGrid) {
            grid = main.append('g').attr('class', 'grid');

            createGridLines = function(yAxisMax) {
              grid.selectAll('line.gridline').remove();
              grid.selectAll('line.gridline')
                .data(self._getNumberedAxisTickValues(0, yAxisMax, chartHeight))
                .enter()
                .append('line')
                .attr('class', 'gridline')
                .attr('x1', 0)
                .attr('x2', xAxisMax)
                .attr('y1', function(d) { return y(d); })
                .attr('y2', function(d) { return y(d); })
                .style('fill', 'none')
                .style('shape-rendering', 'crispEdges')
                .style('stroke', '#757575')
                .style('stroke-width', '1px');
            };

            createGridLines(yAxisMax);
          }

          main.append('g')
            .attr('class', 'bars')
            .selectAll('.bar.stack')
            .data(bars)
            .enter().append('g')
            .attr('class', 'bar stack')
            .attr('transform', function(d) { return 'translate(' + x(d.barValue) + ',0)'; })
            .selectAll('rect')
            .data(function(d) { return d.stacks; })
            .enter().append('rect')
            .attr('class', 'bar')
            .attr('width', function() { return Math.max(x.rangeBand(), 2); })
            .attr('y', function(d) { return y(d.stackEnd); })
            .attr('height', function(d) { return y(d.stackStart) - y(d.stackEnd); })
            .style('stroke', 'rgba(0,0,0,0)')
            .style('stroke-width', '1px')
            .style('fill', function(d) {
              if(d.stackLabel === self.defaultLabel || !color(d.stackLabel)) {
                return defaultColor;
              }
              return color(d.stackLabel);
            })
            .on('mouseout', function() {
              info.text(createExtentText());
            })
            .on('mousemove', function(d) {
              // Add commas to pretty format numbers.
              var barLabel = self._numberToString(d.barCount);
              var stackLabel = self._numberToString((d.stackEnd - d.stackStart));
              info.text(d.barLabel + ':  ' + (d.stackLabel ? (d.stackLabel + ' ') : '') + '(' + stackLabel + ' of ' + barLabel + ')');
            });

          if(!this.hideOverview) {
            overview.append('g')
              .attr('class', 'bars')
              .selectAll('.bar')
              .data(bars)
              .enter().append('rect')
              .attr('class', 'bar')
              .attr('x', function(d) { return xOverview(d.barValue) - 3; })
              .attr('width', function() { return Math.max(xOverview.rangeBand(), 8); })
              .attr('y', function(d) { return yOverview(d.barCount); })
              .attr('height', function(d) { return overviewHeight - yOverview(d.barCount); })
              .style('stroke', '#212121')
              .style('stroke-width', '1px')
              .style('fill', '#212121');
          }

          var brush = d3.svg.brush().x(xOverview);

          var onBrushed = function() {
            var extent = brush.extent();
            var xWidth = xOverview.rangeBand();

            self._setXAxis(timeline, interval, brush.empty() ? bars : bars.filter(function(bar) {
              var xValue = xOverview(bar.barValue);
              return (extent[0] <= xValue + xWidth) && (xValue <= extent[1]);
            }), chartWidth, x, xAxis, self.hideAxes);

            main.selectAll('.bar.stack .bar').attr('width', function() { return Math.max(x.rangeBand(), 8); });

            info.text(createExtentText());

            var yAxisMax = 0;
            main.selectAll('.bar.stack')
              .attr('transform', function(d) {
                var barX = x(d.barValue);
                // A buffer (5 pixels seems sufficient) is needed to show the bars at the start and end of the chart.
                if(barX > -5 && barX < xAxisMax + 5) {
                  yAxisMax = Math.max(yAxisMax, d.barCount);
                  return 'translate(' + barX + ',0)';
                } else {
                  return 'translate(0,0),scale(0)';
                }
              });

            var ticks = self._getNumberedAxisTickValues(0, yAxisMax, chartHeight);
            yAxisMax = ticks[ticks.length - 1];
            y.domain([0, yAxisMax]);

            if(!this.hideAxes) {
              yAxis.tickValues(ticks);

              main.select('.x.axis').call(xAxis);
              main.select('.y.axis').call(yAxis);

              // For whatever reason (polymer?) the stroke color of the ticks isn't correctly applied once the axes are redrawn so we must reapply it here.
              main.selectAll('.axis .tick line').attr('stroke', '#212121');
            }

            main.selectAll('.bar.stack rect')
              .attr('y', function(d) { return y(d.stackEnd); })
              .attr('height', function(d) { return y(d.stackStart) - y(d.stackEnd); });

            if(!this.hideAxes && !this.hideGrid) {
              grid.selectAll('line.gridline').remove();
              createGridLines(yAxisMax);
            }
          };

          brush.on('brush', onBrushed);

          // When user finishes selecting an area, save that selection in selected property
          // (or clear that property if user clears their selection)
          var onBrushEnd = function() {
            var selectedPath = self.selectedProperty ? ['selected', self.selectedProperty] : 'selected';
            if(!brush.empty() && x.domain().length) {
              // if this is a timeline, get the start and end values (otherwise, use entire selection)
              self.set(selectedPath, timeline ? [self._formatDateToESString(x.domain()[0]),
                self._formatDateToESString(x.domain()[x.domain().length - 1])] : x.domain());
            } else {
              self.set(selectedPath, []);
            }
          };

          brush.on('brushend', onBrushEnd);

          // if selected has previously been set and the chart is being resized, manually set brush based on those values
          if(self.selected) {
            var selected = self.selectedProperty ? self.selected[self.selectedProperty] : self.selected;
            if(selected.length && bars) {
              var extentCalculation;
              if(timeline) {
                extentCalculation = d3.extent(bars.map(function(bar) {
                  if(new Date(selected[0]) <= bar.barValue && new Date(selected[1]) >= bar.barValue) {
                    return x(bar.barValue) + x.rangeBand() / 2;
                  }
                }));
              } else {
                extentCalculation = d3.extent(bars.map(function(bar) {
                  if(selected[0] === bar.barValue ||
                    selected[selected.length - 1] === bar.barValue) {
                    return x(bar.barValue) + x.rangeBand() / 2;
                  }
                }));
              }
              // if extent is only one bar, make sure to redraw brush only around that bar
              if(extentCalculation[0] === extentCalculation[1]) {
                var singlePercentageOfBarWidth = x.rangeBand() / 100 * 0.01;
                extentCalculation[0] = extentCalculation[0] - (x.rangeBand() / 2) + singlePercentageOfBarWidth;
                extentCalculation[1] = extentCalculation[1] + (x.rangeBand() / 2) - singlePercentageOfBarWidth;
              }
              brush.extent(extentCalculation);
              onBrushed();
            }
          }

          if(!this.hideOverview) {
            overview.append('g')
              .attr('class', 'x brush')
              .call(brush)
              .selectAll('rect')
              // -6 is magic number to offset positions for styling/interaction to feel right
              .attr('y', -6)
              // need to manually set the height because the brush has
              // no y scale, i.e. we should see the extent being marked
              // over the full height of the overview chart
              .attr('height', overviewHeight + 7);  // +7 is magic number for styling
          }

          this.$.barChart.setAttribute('style', 'height: ' + this.height + 'px; width: 100%');

          var children = this.$.barChart.children;
          for(var i = 0; i < children.length; i++) {
            this.$.barChart.removeChild(children[i]);
          }

          this.$.barChart.appendChild(svg.node());

          d3.select(window).on('resize.' + this._uuid, function() {
            self.resize();
          });
        },

        /**
         * Get the appropriate d3 time format based on the interval specified.
         *
         * @param {String} interval
         * @return {Object} d3 time formatter
         * @private
         */
        _getD3Interval: function(interval) {
          if(interval === 'hour') {
            return d3.time.hour;
          }
          if(interval === 'day') {
            return d3.time.day;
          }
          if(interval === 'week') {
            // Use d3.time.monday for weeks because elasticsearch date histogram aggregations return weeks that start on Mondays.
            return d3.time.monday;
          }
          if(interval === 'month') {
            return d3.time.month;
          }
          return d3.time.year;
        },

        /**
         * Get text to use for date labels.
         *
         * @param {Date} date object
         * @param {String} interval
         * @return {Object} d3 time formatter
         * @private
         */
        _getDateText: function(date, interval) {
          if(interval === 'week') {
            return 'Week of ' + moment(date).format('MMM D, YYYY');
          }
          if(interval === 'month') {
            return 'Month of ' + moment(date).format('MMM YYYY');
          }
          if(interval === 'year') {
            return 'Year of ' + moment(date).format('YYYY');
          }
          return interval === 'day' ? moment(date).format('MMM D, YYYY') : moment(date).format('HH:mm MMM D, YYYY');
        },

        /**
         * Creates a string representation of a date to use to query
         * elasticsearch (ex: '2016-08-02T00:00:00')
         *
         * @param {Date} date
         * @return {String} date as string
         */
        _formatDateToESString: function(date) {
          return moment(date).format('YYYY-MM-DD') + 'T00:00:00';
        },

        /**
         * Returns domain values for this bar chart based on parameters.
         *
         * @param {Array} bars
         * @param {Boolean} timeline
         * @param {String} interval
         * @param {Number} chartWidth
         * @return {Array} domain values
         * @private
         */
        _getDomain: function(bars, timeline, interval, chartWidth) {
          if(timeline) {
            return d3.time.scale().range([0, chartWidth]).domain(d3.extent(bars, function(bar) {
              return bar.barValue;
            })).ticks(this._getD3Interval(interval), 1);
          }
          return bars.map(function(bar) {
            return bar.barValue;
          });
        },

        /**
         * Returns correct format for displaying current date domain values.
         *
         * @param {Array} domain
         * @param {String} interval
         * @return {String} format
         * @private
         */
        _getDomainTimeFormat: function(domain, interval) {
          var diffInDays = (((((domain[domain.length - 1] - domain[0]) / 1000) / 60) / 60) / 24);
          if(interval === 'year') {
            return '%Y';
          }
          if(diffInDays > 330 && interval === 'month') {
            return '%b %Y';
          }
          if(interval === 'month') {
            return '%b';
          }
          if(diffInDays > 330) {
            return '%b %e %Y';
          }
          return '%b %e';
        },

        /**
         * Returns tick values for the y-axis.
         *
         * @param {Number} barMin
         * @param {Number} barMax
         * @param {Number} height
         * @return {Array} tick values
         * @private
         */
        _getNumberedAxisTickValues: function(barMin, barMax, height) {
          // One tick plus one per 20 px in height.  Return at most 11 tick values.  EX:  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          var valueCount = Math.min(11, Math.floor(height / 20.0) + 1);
          if(valueCount < 3) {
            return [barMin, barMax];
          }

          var difference = Math.ceil(barMax - barMin);
          if(difference < valueCount) {
            // Always set the end of the range to the max plus one so the max is added to the range if it is evenly divisible.
            return _.range(barMin, barMax + 1);
          }

          if(valueCount === 3) {
            var middle = Math.ceil(difference / 2.0);
            // Use the middle rather than the barMax here so the middle number is evenly spaced between the min and max.  This may add 1 to the max.
            return [barMin, (barMin + middle), (barMin + 2 * middle)];
          }

          var text = difference.toString();
          var size = text.length;
          var step = Math.pow(10, size - 1);
          var timesTwo = false;

          // Increase the step if able due to the difference.
          if(size > 1) {
            if(difference === step) {
              // EX:  difference = 100
              step = Math.pow(10, size - 2);
            } else if((_.startsWith(text, '1') && difference !== step) || (_.startsWith(text, '2') && difference === 2 * step)) {
              // EX:  difference = 123 OR 200
              step = 2 * Math.pow(10, size - 2);
              timesTwo = true;
            } else if(_.startsWith(text, '2') || _.startsWith(text, '3') || _.startsWith(text, '4') || (_.startsWith(text, '5') && difference === 5 * step)) {
              // EX:  difference = 234 OR 345 OR 456 OR 500
              step = 5 * Math.pow(10, size - 2);
            }
          }

          var values = _.range((Math.floor(barMin / step) * step), (Math.ceil(barMax / step) * step) + 1, step);

          // Increase the step if needed due to the valueCount.
          if(values.length > valueCount && !timesTwo) {
            step = 2 * step;
            values = _.range((Math.floor(barMin / step) * step), (Math.ceil(barMax / step) * step) + 1, step);
          }
          if(values.length > valueCount) {
            step = (step / 2) * 5;
            values = _.range((Math.floor(barMin / step) * step), (Math.ceil(barMax / step) * step) + 1, step);
          }
          if(values.length > valueCount && timesTwo) {
            step = Math.pow(10, size - 1);
            values = _.range((Math.floor(barMin / step) * step), (Math.ceil(barMax / step) * step) + 1, step);
          }

          return values;
        },

        /**
         * If number of domain values is over a certain threshold (in this case 10), truncate.
         *
         * @param {Array} domain
         * @return {Array} truncatedDomain
         * @private
         */
        _getTruncatedDomain: function(domain) {
          // Only show a maximum of 10 (an arbitrary number that looks good) labels on the x-axis.
          var step = Math.ceil(domain.length / 10.0);
          var truncatedDomain = [];
          for(var i = 0; i < domain.length; i += step) {
            truncatedDomain.push(domain[i]);
          }
          return truncatedDomain;
        },

        /**
         * Create x axis.
         *
         * @param {Boolean} timeline
         * @param {String} interval
         * @param {Array} data
         * @param {Number} chartWidth
         * @param {Object} x
         * @param {Object} xAxis
         * @param {Object} xOverview
         * @param {Object} xAxisOverview
         * @param {Boolean} hideAxes
         * @private
         */
        _setXAxis: function(timeline, interval, data, chartWidth, x, xAxis, xOverview, xAxisOverview, hideAxes) {
          var xDomain = this._getDomain(data, timeline, interval, chartWidth);
          x.domain(xDomain).rangeBands([0, chartWidth]);
          if(xOverview) {
            xOverview.domain(x.domain()).rangeBands([0, chartWidth]);
          }

          if(!hideAxes) {
            if(timeline) {
              var timeFormat = this._getDomainTimeFormat(xDomain, interval);
              xAxis.tickFormat(d3.time.format(timeFormat));
              if(xAxisOverview) {
                xAxisOverview.tickFormat(d3.time.format(timeFormat));
              }
            }

            var xTruncatedDomain = this._getTruncatedDomain(xDomain);
            xAxis.tickValues(xTruncatedDomain);
            if(xAxisOverview) {
              xAxisOverview.tickValues(xTruncatedDomain);
            }
          }
        },

        /**
         * Return the correct instructions to display in the selection area based on the value of displayFilterText.
         *
         * @return {String} instructionText
         * @private
         */
        _getSelectionInstructions: function() {
          if(this.displayFilterText) {
            return 'Click + drag on the chart below to zoom + filter.  Click elsewhere to reset.';
          } else {
            return 'Click + drag on the chart below to zoom.  Click elsewhere to reset the zoom.';
          }
        },

        /**
         * Formats the given number for the Y-axis ticks and returns it as a string.
         *
         * @param {Number} tick
         * @return {String}
         * @private
         */
        _formatTickY: function(tick) {
          var tickString = '' + Math.round(tick);
          if(tick >= 1000000000000) {
            var secondary = parseInt(tickString.substring(tickString.length - 12));
            secondary = Math.trunc(Math.round(secondary / 100000000000.0));
            var primary = parseInt(tickString.substring(0, tickString.length - 12)) + (secondary === 10 ? 1 : 0);
            return primary + (secondary > 0 && secondary < 10 ? '.' + secondary : '') + ' T';
          }
          if(tick >= 1000000000) {
            var secondary = parseInt(tickString.substring(tickString.length - 9));
            secondary = Math.trunc(Math.round(secondary / 100000000.0));
            var primary = parseInt(tickString.substring(0, tickString.length - 9)) + (secondary === 10 ? 1 : 0);
            if(primary === 1000) {
              return '1 T';
            }
            return primary + (secondary > 0 && secondary < 10 ? '.' + secondary : '') + ' B';
          }
          if(tick >= 1000000) {
            var secondary = parseInt(tickString.substring(tickString.length - 6));
            secondary = Math.trunc(Math.round(secondary / 100000.0));
            var primary = parseInt(tickString.substring(0, tickString.length - 6)) + (secondary === 10 ? 1 : 0);
            if(primary === 1000) {
              return '1 B';
            }
            return primary + (secondary > 0 && secondary < 10 ? '.' + secondary : '') + ' M';
          }
          if(tick >= 1000) {
            var secondary = parseInt(tickString.substring(tickString.length - 3));
            secondary = Math.trunc(Math.round(secondary / 100.0));
            var primary = parseInt(tickString.substring(0, tickString.length - 3)) + (secondary === 10 ? 1 : 0);
            if(primary === 1000) {
              return '1 M';
            }
            return primary + (secondary > 0 && secondary < 10 ? '.' + secondary : '') + ' K';
          }
          return tickString;
        },

        /**
         * Formats the given number with commas and returns it as a string.
         *
         * @param {Number} number
         * @return {String}
         * @private
         */
        _numberToString: function(number) {
          var string = number.toString();
          var prefix = string.indexOf('.') >= 0 ? string.substring(0, string.indexOf('.')) : string;
          var suffix = string.indexOf('.') >= 0 ? string.substring(string.indexOf('.')) : '';
          return prefix.replace(/\B(?=(\d{3})+(?!\d))/g, ',') + suffix;
        },

        /**
         * Recreate elements when window is resized.
         */
        resize: function() {
          this._createElements(this._bars, this.interval, this.timeline);
        }
      });
    })();
  </script>
</dom-module>
